# Labels

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se.e = FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size")
```

subtitle adds additional detail in a smaller font beneath the title and caption adds text at the bottom right of the plot 
caption adds text at the bottom right of the plot, often used to describe the source of the data.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Fuel efficiency generally decreases with engine size",
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",
    caption = "Data from fueleconomy.gov"
  )
```
use labs() to replace axis labels and legend titles.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    colour = "Car type"
  )
```
# Annotations
use geom_text() to add textual labels to your plots. This works in the same way as geom_point() but rather than a shape geometry it can add a label. 

Here we will filter the data (more to come on this in the next workshop!) and add a label that calls in the values from the data frame. This is really neat, because it allows us to pull data values out (like the most fuel efficient car!) from the data itself and include it in the plot. This is particularly nice when these might change on an update of the data. 

```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)
```
Although the labels overlap, there are ways you can handle that issue if you ever find it a problem. These include a nudge() function to move your text a certain amount and using other R packages to handle text wrapping etc.  

# Scales
ggplot normally adds default scale for you
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()
```
# Axis ticks
You can also change the ticks on your axes. Breaks controls the position of the ticks and you can use labels as an argument to change the text label associated with ticks.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
```
Similarly, you can use labels set to NULL to suppress the labels altogether. This is sometimes an option if you’re trying to format your plots in a particular way. 

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
```
# Legends and colour schemes
To control the overall position of the legend, you need to use a theme() setting
can also use legend.position = "none" to suppress the display of the legend altogether!
```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default
```
# Replacing a scale
There are two types of scales you’re mostly likely to want to switch out: continuous position scales and colour scales.
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```
Another scale that is frequently customised is the colour scale
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv))

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) +
  scale_colour_brewer(palette = "Set1")
```
If there are just a few colours, you can add a redundant shape mapping. This will also help ensure your plot is interpretable in black and white.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_colour_brewer(palette = "Set1")
```
When you have predefined colours you want to use you can set them yourself, using scale_colour_manual()
```{r}
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))

```
```{r}
df <- tibble( # note we're just making a fake dataset so we can plot it
  x = rnorm(10000),
  y = rnorm(10000)
)
ggplot(df, aes(x, y)) +
  geom_hex() + # a new geom!
  coord_fixed()

ggplot(df, aes(x, y)) +
  geom_hex() +
  viridis::scale_fill_viridis() +
  coord_fixed()
```
# Themes
And finally, now you can customize the entire theme of your plot. Themes allow you to change some or all of the non-data elements of your plot with a theme.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()
```
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light()
```
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic()
```
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark()
```
One particularly nice thing you can do is to develop your own themes simply by setting some or all of the arguments to theme() yourself. Here’s one I wrote so that my plots are always the same style:
```{r}
 theme (panel.border = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position="bottom",
        legend.title=element_blank(),
        legend.text=element_text(size=8),
        panel.grid.major = element_blank(),
        legend.key = element_blank(),
        legend.background = element_blank(),
        axis.text.y=element_text(colour="black"),
        axis.text.x=element_text(colour="black"),
        text=element_text(family="Arial")) 
```
# Saving and exporting your plots
the best way to make a single file will be to export it using the ggsave() function.
```{r}
ggplot(mpg, aes(displ, hwy)) + geom_point()

ggsave("my-plot.pdf")
#> Saving 7 x 4.32 in image
```

